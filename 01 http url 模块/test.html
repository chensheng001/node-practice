<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>

        //--------------ES5----------原型链继承与对象冒充继承
        function Person(name,age) {
          this.name = name;
          this.age = age;
          this.run = function () {
            console.log(this.name + '在run')
          }
        }

        Person.prototype.sex = 'man';
        Person.prototype.name = 'heihei';
        Person.prototype.work = function () {
          console.log(this.name + '在work')
        }

        let person = new Person('haha', 20);


        function Web(name,age) {
          //Person.apply(this,[name,age]);
          //Person.call(this,name,age);
          Person.bind(this,name,age)();
        }
        Web.prototype = Person.prototype;
        let web = new Web('web', 30);



        //-----------------------------------------------------call, apply,bind 改变this指针
        var cat = {
          name: 'cat',
          eatFish: function (it) {
            console.log(this)
            console.log(it + '在'+'eat fish')
          }
        };
        var dog = {
          name: 'dog',
          wangwang: function () {
            console.log(this.name + '在'+'wang wang')
          }
        };

        //cat.eatFish.apply(dog, [dog.name]);
        //let eat = cat.eatFish.bind(dog,dog.name);
        //eat();
        
        //-------call原理
        Function.prototype.call = function (thisArg,...arg) {
          if (typeof this !== 'function') {
            throw new TypeError('Error')
          }
          thisArg = thisArg || window;
          thisArg.fn = this;
          console.log(arg)
          /*let argArr = Array.from(arguments);
          const res = thisArg.fn(...argArr.slice(1));*/
          const res = thisArg.fn(arg);
          delete thisArg.fn;
          return res;
        };
        //cat.eatFish.call(dog,dog.name);

        //-------apply原理
        Function.prototype.apply = function (thisArg, arg) {
          if (typeof this !== 'function') {
            throw new TypeError('Error')
          }
          thisArg = thisArg || window;
          thisArg.fn = this;
          const res = thisArg.fn(...arg);
          delete thisArg.fn;
          return res;
        };
        //cat.eatFish.apply(dog, [dog.name]);

        //------------------------------------------------------闭包

        function add() {
          let count = 0;
          return function () {
            return count++;
          }
        }

        let p = add();
        /*console.log(p())
        console.log(p())
        console.log(p())*/

        //-----------------async-------------
        function sleep() {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve('sleep done');
            }, 1000)
          })
        }

        async function myfun() {
          console.log('------------------')
          const data = await sleep();
          console.log(data,'--------myfun')
          return data;
        }

        /*myfun().then(res => {
          console.log(res,'------------final')
        }).catch(err => {});*/


        //--------------------------------generator 函数

        function promise1() {
          return new Promise(resolve => {
            resolve('promise1')
          }, 100)
        }

        function promise2() {
          return new Promise(resolve => {
            resolve('promise2')
          }, 200)
        }

        function * gen() {
          yield promise1();
          yield promise2();
          return 'gen';
        }

        let hw = gen();
        /*console.log(hw.next());
        console.log(hw.next());
        console.log(hw.next());
        console.log(hw.next());*/

        const pro = Promise.resolve('aaa');

        //-----------------------------变量解构
        function f(x,y) {
          console.log(x,y)
        }
        //f(...[1,2])
        function add(...args) {
          console.log(args)
        }
        add(1,2,3)


    </script>
</head>
<body>

</body>
</html>